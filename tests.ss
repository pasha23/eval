
(define counter (make-counter))

(define integers
    (letrec ((next
              (lambda (n)
                (delay (cons n (next (+ n 1)))))))
            (next 0)))

(define head
    (lambda (stream) (car (force stream))))

(define tail
    (lambda (stream) (cdr (force stream))))

(define (foo x)
        (define (bar x)
                (define (baz x)
                        (product 3 x))
        (product 5
           (baz x)))
    (product 7
       (bar x)))

(define (s n k)
    (cond ((= k 1) 1)
          ((= k n) 1)
          (else (+ (s (- n 1) (- k 1)) (* k (s (- n 1) k))))))

(define (phi)
    (let ((f0 1)
          (f1 1))
         (while (< f0 102334155)
                (let ((t (+ f1 f0))
                      (p (/ f1 f0)))
                     (set! f0 f1)
                     (set! f1 t)
                     (display (list p (exact->inexact p)))
                     (newline)))))

(define (chars n)
        (let ((i 0) (j 0) (k 0) (l '()))
             (set! i 0)
             (while (< i n)
                    (set! j 64)
                    (set! l (cons #\space (cons #\space '())))
                    (while (> j 0)
                           (set! j (- j 1))
                           (when (not (zero? (+ i j)))
                                 (set! l (cons (integer->char (+ i j)) l))))
             (set! l (cons #\space (cons #\space l)))
             (set! k i)
             (set! l (cons (hexdigit (& k 15)) l))
             (set! k (>> k 4))
             (set! l (cons (hexdigit (& k 15)) l))
             (set! k (>> k 4))
             (set! l (cons (hexdigit (& k 15)) l))
             (set! k (>> k 4))
             (set! l (cons (hexdigit (& k 15)) l))
             (set! k (>> k 4))
             (set! l (cons (hexdigit (& k 15)) l))
             (display (list->string l))
             (display i)
             (newline)
             (set! i (+ i 64)))))

;; (with-output-to-file "chartable" (lambda () (chars (hexin "10000"))))

(define (triples maxPeri)

    (define (area l)
            (let* ((a (car l))
                   (b (cadr l))
                   (c (caddr l))
                   (p (/ (+ a b c) 2)))
                  (sqrt (* p (- p a) (- p b) (- p c)))))

    (define (compare-areas x y)
            (< (area x) (area y)))

    (define (perimeter l)
            (+ (car l) (cadr l) (caddr l)))

    (define (compare-perimeters x y)
            (< (perimeter x) (perimeter y)))

    (let ((result '()))

         (define (newtri a b c)

                 (let ((p (+ a b c)))

                      (when (<= p maxPeri)

                            (set! result (cons (sort < (list a b c)) result))

                            (newtri (+ (* 1 a) (* -2 b) (* 2 c))
                                    (+ (* 2 a) (* -1 b) (* 2 c))
                                    (+ (* 2 a) (* -2 b) (* 3 c)))

                            (newtri (+ (* 1 a) (* 2 b) (* 2 c))
                                    (+ (* 2 a) (* 1 b) (* 2 c))
                                    (+ (* 2 a) (* 2 b) (* 3 c)))

                            (newtri (+ (* -1 a) (* 2 b) (* 2 c))
                                    (+ (* -2 a) (* 1 b) (* 2 c))
                                    (+ (* -2 a) (* 2 b) (* 3 c))))))

         (newtri 3 4 5)

         (sort compare-perimeters result)))

(define (factor n)
        (let ((r '())
              (d 2))
        (if (< n 2)
            (list n)
            (begin (while (<= d n)
                          (while (zero? (remainder n d))
                                 (set! n (quotient n d))
                                 (set! r (cons d r)))
                          (set! d (+ d 1)))
                   (reverse! r)))))

(define (collapse s)
        (if (null? s)
            s
            (let ((n (car s))
                  (k 0))
                 (while (and (pair? s) (= n (car s)))
                        (set! k (+ k 1))
                        (set! s (cdr s)))
                 (cons (list n k) (collapse s)))))

(define (compose f g) (lambda x (apply f (apply g x))))

(define (prime? x)
        (if (> x 1)
            (let ((f #t)
                  (c 3))
                 (while (and f (<= (* c c) x))
                        (when (zero? (remainder x c)) (set! f #f))
                        (set! c (+ c 2)))
                 f)
             #f))

(define (primes limit)
        (let* ((n 3)
               (l (cons 2 '()))
               (end l))
             (while (<= n limit)
                    (when (prime? n)
                          (set-cdr! end (cons n '()))
                          (set! end (cdr end)))
                    (set! n (+ n 2)))
             l))

(define (sieve limit)
        (let* ((primes (cons 2 '()))
               (ps primes)
               (end primes)
               (n 3))
              (while (<= n limit)
                     (if (null? ps)
                         (begin (set-cdr! end (cons n '()))
                                (set! end (cdr end))
                                (set! n (+ n 2))
                                (set! ps primes))
                         (if (zero? (remainder n (car ps)))
                             (begin (set! n (+ n 2))
                                    (set! ps primes))
                             (set! ps (cdr ps)))))
                  primes))

(define bbbbb '(b))
(define aaaaa (list bbbbb bbbbb bbbbb bbbbb bbbbb))
(set-cdr! (cddddr aaaaa) aaaaa)

(define (test s)
        (unless (eq? #t (eval s (environment)))
            (begin (display 'fail) (space) (write s) (newline)))
        (gc))

;; (define (test s)
;;         (if (eq? #t (eval s (environment)))
;;             (begin (display 'pass) (space) (write s) (newline))
;;             (begin (display 'fail) (space) (write s) (newline)))
;;         (gc))

;; (test '(not (equal? '#0=(a b a . #0#) '#1=(a b a b . #1#))))

(define test0 '(a b a))
(set-cdr! (cddr test0) test0)
(define test1 '(a b a b))
(set-cdr! (cdddr test1) test1)
(test '(not (equal? test0 test1)))

(test '(equal? "(#0=(abc def A foo) #0#)"
               (let* ((x '(abc def A foo))
                      (y (list x x))
                      (out (open-output-string)))
                 (write-shared y out)
                 (get-output-string out))))

(test '(equal? "(#0=(abc def A foo) #0#)(abc def A foo)(\"abc\" \"def\" #\\A foo)"
      (let* ((x '("abc" "def" #\A foo))
             (y (list x x))
             (out (open-output-string)))
        (display y out)
        (display-simple x out)
        (write-simple   x out)
        (get-output-string out))))

(test '(equal? "abc def"
               (let ((out (open-output-string)))
                    (write-string "abc def" out)
                    (get-output-string out))))

(test '(equal? "def"
               (let ((out (open-output-string)))
                    (write-string "abc def" out 4)
                    (get-output-string out))))

(test '(equal? "c d"
               (let ((out (open-output-string)))
                    (write-string "abc def" out 2 5)
                    (get-output-string out))))

(test '(equal?
      "((a b c d) (a b c d))"
      (let* ((x '(a b c d))
             (y (list x x))
             (out (open-output-string)))
          (write-simple y out)
          (get-output-string out))))

(test '(equal?
      "(#0=(a b c d) #0#)"
      (let* ((x '(a b c d))
             (y (list x x))
             (out (open-output-string)))
        (write-shared y out)
        (get-output-string out))))

(test '(equal? '((-7 -6 11) (-17 -20 25))
             (matrix-multiply '((1 2) (3 4)) '((-3 -8 3) (-2 1 4)))))

(test '(equal? '((2 15) (3 6) (5 3) (7 2) (11 1) (13 1))
             (collapse (factor (fac 16)))))

(test '(equal? (triples 100)
             '((3 4 5) (5 12 13) (8 15 17) (7 24 25) (20 21 29) (12 35 37) (9 40 41))))

(test '(equal? '(1 2 4 5 7 8) (sort < '(1 4 2 8 5 7))))

(test '(string=?  "aaaaabbcdrr" (list->string (sort char<? (string->list "abracadabra")))))

(test '(equal? (iota 5) (sort < (sort (make-lfsr 6) (iota 5)))))

(test '(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
                (g (lambda () (if (eqv? f g) 'g 'both))))
               (not (eqv? f g))))

(test '(= 0 0))
(test '(= (~ 0) -1))
(test '(= 1.0 (cos (acos 1.0))))
(test '(= 1.0 (exp 0.0)))
(test '(= 1.0 (floor 1.5)))
(test '(= 1.0 (sin (asin 1.0))))
(test '(= -1.0 (truncate -1.5)))
(test '(= 1 (* 2/3 3/2)))
(test '(= (- 1 2 3) -4))
(test '(= 128 (expt 2 7)))
(test '(= 1 (% 3 2)))
(test '(= 13 (fib 5)))
(test '(= 1/6 (- 1/2 1/3)))
(test '(= 1764 (square 42)))
(test '(= 1 (>> 8 3)))
(test '(= 1 (cos (acos 1))))
(test '(= 1 (counter)))
(test '(= 1 (exp 0)))
(test '(= 1 (floor 1.5)))
(test '(= 1 (sin (asin 1))))
(test '(= -1+0i (square 0+1i)))
(test '(= -1 (truncate -1.5)))
(test '(= 2.0 (+ 2.0 (epsilon))))
(test '(= 2.0 (exact->inexact 2)))
(test '(= 2 2))
(test '(< 2 3))
(test '(= 2 (- 5 3)))
(test '(= 29 (ack 3 2)))
(test '(= 2 (counter)))
(test '(= 2 (exact->inexact 2)))
(test '(= 2 (gcd 12 10)))
(test '(= 2 (head (tail (tail integers)))))
(test '(= 3.0 (imag-part 5.0+3.0i)))
(test '(= 30 (lcm 12 10)))
(test '(= 3.0 (round 3.1)))
(test '(= 3.0 (sqrt 9.0)))
(test '(= 3 (/ 12 4)))
(test '(= '3 (+ 2 1)))
(test '(= (% 3 2) 1))
(test '(= 3 (+ 2 1)))
(test '(= 3/2 (/ 3/4 1/2)))
(test '(= 3/2 (rationalize 1.5 1e-7)))
(test '(<= 3 3))
(test '(= 3 3))
(test '(>= 3 3))
(test '(= (* 3 4) 12))
(test '(= (+ 3 4) 7))
(test '(= 3628800 (let ((p 1) (n 10)) (while (> n 0) (set! p (* n p)) (set! n (- n 1)) p))))
(test '(= 362880 (apply * (cdr (iota 10)))))
(test '(= 3 (begin 1 2 3)))
(test '(= 3 (counter)))
(test '(= 3 (if #t 3 2)))
(test '(= 3 (imag-part 5+3i)))
(test '(= 3 (inexact->exact 3)))
(test '(= 3 (inexact->exact 3.0)))
(test '(= 3 (isqrt 9)))
(test '(= 3 (length '(a b c))))
(test '(= 3 (let ((r 0)) (begin (unless #f 1 2 (set! r 3)) r))))
(test '(= 3 (let ((r 0)) (begin (when   #t 1 2 (set! r 3)) r))))
(test '(= 3 (max 1 3 2)))
(test '(= 3 (min 4 3 6)))
(test '(= 3 (round 3.1)))
(test '(= 3 (sqrt 9)))
(test '(= 3 (string-length "abc")))
(test '(= 3 (string->number "3")))
(test '(= 3 (vector-length (list->vector (list 1 2 3)))))
(test '(= 3 (vector-length (vector 1 2 3))))
(test '(= 4.0 (imag-part 3.0+4.0i)))
(test '(= 4.0  (square 2.0)))
(test '(= (/ 4 2) 2))
(test '(= 45.0 (real-part 45.0+18.0i)))
(test '(= 45 (real-part 45+18i)))
(test '(= 45 (string-length (make-string 45))))
(test '(= 4 (cond (#f 1) (#f 2) (#t 3 4) (#f 4) (else 5))))
(test '(= 4 (imag-part 3+4i)))
(test '(= 5.0 (real-part 5.0+3.0i)))
(test '(= (& 5 2) 0))
(test '(= 525 (foo 5)))
(test '(> 5 3))
(test '(= 5 (| 4 1)))
(test '(= 5/6 (+ 1/2 1/3)))
(test '(= 5 (cond (#f 1) (#f 2) (#f 3) (#f 4) (else 5))))
(test '(= 5 (force (delay 5))))
(test '(= 5 (real-part 5+3i)))
(test '(= 6 (* 2 3)))
(test '(= 65 (char->integer #\A)))
(test '(= 6 (fac 3)))
(test '(= 6 (tak 7 6 5)))
(test '(= 7129/2520 (apply + (map / (cdr (iota 10))))))
(test '(= (^ 7 2) 5))
(test '(= 77 (do ((i 1 (+ 1 i))) ((> i 4) 77) i)))
(test '(= 7 (eval '(+ 3 4) (environment))))
(test '(= 7 (s 4 2)))
(test '(= 8 (<< 1 3)))
(test '(= 97 (char->integer #\a)))
(test '(<= (abs (- 1.0 (log (exp 1.0)))) 1e-7))
(test '(<= (abs (- 1.0 (tan (atan 1.0)))) 1e-7))
(test '(<= (abs (- 1 (log (exp 1)))) 1e-07))
(test '(<= (abs (- 1 (tan (atan 1)))) 1e-07))
(test '(= (abs -7) 7))
(test '(<= (abs (- 8.0 (pow 2.0 3.0))) 1e-7))
(test '(<= (abs (- 8 (pow 2 3))) 1e-07))
(test '(<= (abs (- (sqrt 2.0) (magnitude 1.0+1.0i))) 1e-7))
(test '(<= (abs (- (sqrt 2) (magnitude 1+1i))) 1e-07))
(test '(alist? '((a . b) (c . d))))
(test '(and #t #t))
(test '(< (- (angle 1.0+1.0i) 0.785398163397448) 1e-7))
(test '(< (- (angle 1+1i) 0.785398163397448) 1e-07))
(test '(boolean? (eq? "" "")))
(test '(boolean? (eq? '(a) '(a))))
(test '(boolean? (eq? "a" "a")))
(test '(boolean=? #f))
(test '(boolean=? #t))
(test '(boolean=? #t #t #t (= 2 2)))
(test '(= (ceiling 1.5) 2))
(test '(= (ceiling 1.5) 2.0))
(test '(char? #\a))
(test '(char<=? #\a #\a))
(test '(char=? #\a #\a))
(test '(char>=? #\a #\a))
(test '(char=? #\A #\A))
(test '(char=? #\a #\a #\a))
(test '(char<=? #\a #\b))
(test '(char<? #\a #\b))
(test '(char<=? #\a #\b #\b))
(test '(char<? #\a #\b #\c))
(test '(char=? #\a (char-downcase #\a)))
(test '(char=? #\a (char-downcase #\A)))
(test '(char=? #\a (char-foldcase #\a)))
(test '(char=? #\a (char-foldcase #\A)))
(test '(char=? #\A (char-upcase #\a)))
(test '(char=? #\A (char-upcase #\A)))
(test '(char=? #\A (integer->char 65)))
(test '(char=? #\a (integer->char 97)))
(test '(char-alphabetic? #\a))
;; (test '(char-alphabetic? #\Λ))
(test '(char=? #\A (string-ref "aAa" 1)))
(test '(char>=? #\b #\a))
(test '(char>? #\b #\a))
(test '(char>=? #\b #\b #\a))
(test '(char>? #\c #\b #\a))
(test '(char-ci=? #\a #\a))
(test '(char-ci>=? #\a #\A))
(test '(char-ci<=? #\A #\a))
(test '(char-ci=? #\A #\a))
(test '(char-ci=? #\a #\A #\a))
(test '(char-ci<=? #\A #\b))
(test '(char-ci<=? #\a #\B #\b))
(test '(char-ci<? #\a #\B #\c))
(test '(char-ci>=? #\B #\a))
(test '(char-ci>? #\B #\a))
(test '(char-ci>=? #\b #\B #\a))
(test '(char-ci<? #\B #\c))
(test '(char-ci>? #\c #\B #\a))
(test '(char-lower-case? #\a))
;; (test '(char-lower-case? #\λ))
(test '(char-numeric? #\0))
;; (test '(char-numeric? #\x0E50))
(test '(char-upper-case? #\A))
;; (test '(char-upper-case? #\Λ))
(test '(char-whitespace? #\newline))
(test '(char-whitespace? #\space))
(test '(char-whitespace? #\tab))
;; (test '(char-whitespace? #\x1680))
;; (test '(char=? #\λ (char-downcase #\Λ)))
;; (test '(char=? #\λ (char-downcase #\λ)))
;; (test '(char=? #\λ (char-foldcase #\Λ)))
;; (test '(char=? #\λ (char-foldcase #\λ)))
;; (test '(char=? #\Λ (char-upcase #\Λ)))
;; (test '(char=? #\Λ (char-upcase #\λ)))
(test '(complex? 3.0+4.0i))
(test '(complex? 3+4i))
(test '(complex? 4.0+3.0i))
(test '(complex? 4+3i))
(test '(eq? '() '()))
(test '(eq? 'a 'a))
(test '(eq? 'a (apply car '((a b)))))
(test '(eq? 'a (car '(a))))
(test '(eq? 'a (vector-ref (list->vector '(b a a)) 1)))
(test '(eq? 'b (cadr '(a b))))
(test '(eq? car car))
(test '(eq? 'c (caddr '(a b c))))
(test '(eq? 'composite (case (* 2 3) ((2 3 5 7) 'prime) ((4 6 8 9) 'composite))))
(test '(eq? 'd (assv 'c '((a . b) (c . d)))))
(test '(eq? 'd (cadddr '(a b c d))))
(test '(equal? '(0 1 2) (let ((a 0) (b 1) (c 2)) (list a b c))))
(test '(equal? '(0 1 2) (let* ((a 0) (b (+ a 1)) (c (+ b 1))) (list a b c))))
(test '(equal? '(1 1/2 1/3 1/4 1/5 1/6 1/7 1/8 1/9) (map / (cdr (iota 10)))))
(test '(equal? '(1 1/2 1/6 1/24 1/120 1/720 1/5040 1/40320 1/362880) (map (lambda (x) (/ (fac x))) (cdr (iota 10)))))
(test '(equal? '(1 2 3) '(1 2 3)))
(test '(equal? '(1 2 3) (list 1 2 3)))
(test '(equal? '(1 2 3) (vector->list '#(1 2 3))))
(test '(equal? "123" (vector->string #(#\1 #\2 #\3))))
(test '(equal? '(1 2)   (vector->list '#(1 2 3) 0 2)))
(test '(equal? '(2.0 3.0) (member 1.99 '(1.0 2.0 3.0) (lambda (x y) (< (abs (- x y)) 0.1)))))
(test '(equal? '(2 3)   (vector->list '#(1 2 3) 1)))
(test '(equal? "23" (vector->string #(#\1 #\2 #\3) 1)))
(test '(equal? '(2 4) (assoc 2.0 '((1 1) (2 4) (3 9)) =)))
(test '(equal? "2" (vector->string #(#\1 #\2 #\3) 1 2)))
(test '(equal? '(3 2 1) (reverse! '(1 2 3))))
(test '(equal? '(42 42 42 42) (make-list 4 42)))
(test '(equal? `(a ,(+ 3 4) b) '(a 7 b)))
(test '(equal? "ab111" (let ((x (string-copy "abcde"))) (string-fill! x #\1 2 5) x)))
(test '(equal? "ab11e" (let ((x (string-copy "abcde"))) (string-fill! x #\1 2 4) x)))
(test '(equal? '(a b 1 2 3 c d) `(a b ,@(list 1 2 3) c d)))
(test '(equal? '(a b) (begin (let ((s '(a a))) (set-cdr! s '(b)) s))))
(test '(equal? '(a b) (begin (let ((s '(b b))) (set-car! s 'a) s))))
(test '(equal? '(a (b) c) '(a (b) c)))
(test '(equal? '(a b c) (cons 'a '(b c))))
(test '(equal? '(a b c d e) (append '(a b c) '(d e))))
(test '(equal? #(a b c d e f) (vector-append #(a b c) #(d e) #(f))))
(test '(equal? "abcde" (let ((x (string-copy "abcde"))) (string-fill! x #\1 2 2) x)))
(test '(equal? #(a b c d e) (vector-append #(a b c) #(d e))))
(test '(equal? '(a b c) (read (open-input-string "(a b c)" 0 7))))
(test '(equal? #(#\A #\B #\C) (string->vector "ABC")))
(test '(equal? #(a b c) (vector-append #() #(a b c))))
(test '(equal? #(a b c) (vector-append #(a b c) #())))
(test '(equal? `(a ,@(list 1 2 3) b c) '(a 1 2 3 b c)))
(test '(equal? `(a (unquote-splicing (list 1 2 3)) b c) '(a 1 2 3 b c)))
(test '(equal? '("b" 4) (assoc "B" '(("a" 1) ("b" 4) ("c" 9)) string-ci=?)))
(test '(equal? '(b) (cdr '(a b))))
(test '(equal? '("b" "c") (member "B" '("a" "b" "c") string-ci=?)))
(test '(equal? #(#\B #\C) (string->vector "ABC" 1)))
(test '(equal? #(#\B) (string->vector "ABC" 1 2)))
(test '(equal? '(c) (cddr '(a b c))))
(test '(equal? '(c . d) (assoc 'c '((a . b) (c . d)))))
(test '(equal? '(c . d) (assq 'c '((a . b) (c . d)))))
(test '(equal? '(c d e) (list-tail '(a b c d e) 2)))
(test '(equal? 'c (list-ref '(a b c d e) 2)))
(test '(equal? '(d) (cdddr '(a b c d))))
(test '(equal? '(e) (cddddr '(a b c d e))))
(test '(equal? '("foo" 2 3) (let ((l (list 1 2 3))) (list-set! l 0 "foo") l)))
(test '(equal? (list 1 2 3) (vector->list (list->vector (list 1 2 3)))))
(test '(equal? (list->vector (list 1 2 3)) (list->vector (list 1 2 3))))
(test '(equal? (list void void void) (make-list 3)))
(test '(equal? (make-vector 5 'a) (make-vector 5 'a)))
(test '(equal? #() (string->vector "")))
(test '(equal? #() (vector-append #() #())))
(test '(equal? #() (vector-append #())))
(test '(equal? "" (vector->string #())))
(test '(eqv? '() '()))
(test '(eqv? 0 (digit-value #\0)))
;; (test '(eqv? 0 (digit-value #\x0AE6)))
(test '(eqv? 100000000 100000000))
(test '(eqv? 2 2))
(test '(eqv? 3 (digit-value #\3)))
;; (test '(eqv? 4 (digit-value #\x0664)))
(test '(eqv? 9 (digit-value #\9)))
(test '(eqv? 'a 'a))
(test '(eqv? #f (digit-value #\-)))
(test '(eqv? #f (digit-value #\.)))
(test '(exact? 2))
(test '(exact-integer? 32))
;; (test '(exact-integer? #e3.0))
;; (test '(finite? 3))
(test '(= (imag-part 3.0+4.0i) 4.0))
(test '(inexact? 3.0))
(test '(inexact? 3.1))
;; (test '(infinite? +inf.0))
;; (test '(infinite? (make-rectangular 3.0 +inf.0)))
(test '(integer? 3))
(test '(let ((b 'b)) (let ((a (list b b b b b))) (set-cdr! (cddddr a) a) (cyclic? a))))
;; (test '(let ((f (fibs))) (= (+ 0.0 (/ (car f) (cadr f))) (/ (+ 1 (sqrt 5)) 2))))
(test '(let ((n (+ 2 3))) (eq? n n)))
(test '(let ((p (lambda (x) x))) (eq? p p)))
(test '(let ((p (lambda (x) x))) (eqv? p p)))
(test '(let ((x '(a))) (eq? x x)))
(test '(let ((x '#())) (eq? x x)))
(test '(list? '(1 2 3)))
;; (test '(nan? (make-rectangular +nan.0 5.0)))
;; (test '(nan? +nan.0))
(test '(negative? -3))
(test '(not (boolean? 5)))
(test '(not (boolean=? #t #t #t (= 2 2) #f)))
(test '(not (char? 0)))
(test '(not (char? 'a)))
(test '(not (char? "a")))
(test '(not (char<? #\a #\a)))
(test '(not (char>? #\a #\a)))
(test '(not (char=? #\a #\A)))
(test '(not (char>=? #\a #\b)))
(test '(not (char>? #\a #\b)))
(test '(not (char-alphabetic? #\space)))
;; (test '(not (char-alphabetic? #\x0E50)))
(test '(not (char<=? #\b #\a)))
(test '(not (char<? #\b #\a)))
(test '(not (char-ci>? #\a #\A)))
(test '(not (char-ci<? #\A #\a)))
(test '(not (char-ci=? #\a #\b)))
(test '(not (char-ci>=? #\A #\b)))
(test '(not (char-ci>? #\A #\b)))
(test '(not (char-ci<=? #\b #\A)))
(test '(not (char-ci<? #\b #\A)))
(test '(not (char-lower-case? #\3)))
(test '(not (char-lower-case? #\A)))
(test '(not (char-lower-case? #\Λ)))
(test '(not (char-numeric? #\.)))
(test '(not (char-numeric? #\a)))
(test '(not (char-numeric? #\Λ)))
(test '(not (char-upper-case? #\3)))
(test '(not (char-upper-case? #\a)))
(test '(not (char-upper-case? #\λ)))
(test '(not (char-whitespace? #\_)))
(test '(not (char-whitespace? #\a)))
(test '(not (eq? (list 'a) (list 'a))))
;; (test '(not (eqv? 0.0 +nan.0)))
(test '(not (eqv? 2 2.0)))
(test '(not (eqv? 'a 'b)))
(test '(not (eqv? (cons 1 2) (cons 1 2))))
(test '(not (eqv? #f 'nil)))
(test '(not (eqv? (lambda () 1) (lambda () 2))))
(test '(not (exact-integer? 32/5)))
(test '(not #f))
;; (test '(not (finite? -inf.0)))
;; (test '(not (finite? +inf.0)))
;; (test '(not (finite? (make-rectangular 3.0 +inf.0))))
(test '(not (inexact? 3)))
;; (test '(not (infinite? 3)))
;; (test '(not (infinite? +nan.0)))
;; (test '(not (nan? 1+2i)))
;; (test '(not (nan? 32)))
(test '(not (null? #f)))
(test '(not (string=? "a" "a" "A" "a")))
(test '(not (string<? "a" "a" "A" "b")))
(test '(not (string? 'abc)))
(test '(not (string<? "a" "B" "c" "D")))
(test '(not (string-ci<? "a" "a" "A" "b")))
(test '(not (string-ci=? "a" "a" "A" "b")))
;; (test '(not (symbol=? 'a 'a "a")))
;; (test '(not (symbol=? '|A| (string->symbol "a"))))
(test '(null? '()))
(test '(number? 3))
(test '(or #f #f #t #f))
(test '(pair? '(a . b)))
(test '(positive? 3))
(test '(procedure? fib))
(test '(procedure? procedure?))
(test '(rational? 5/6))
(test '(real? 45))
(test '(real? 45.0))
(test '(real? 45.1))
(test '(= (sin (asin 1.0)) 1.0))
(test '(= (sin (asin 1)) 1))
(test '(string=? "(0 1 2 3 4 5 6 7 8 " (call-with-truncated-output-string 20 (lambda (port) (write (iota 50) port)))))
(test '(string=? "3" (number->string 3)))
(test '(string<? "a"))
(test '(string=? "a"))
(test '(string=? "a" "a" "a" "a"))
(test '(string=? "AAA" (string-fill! (make-string 3) #\A)))
(test '(string=? "aA" (substring "baA" 1 3)))
(test '(string? "abc"))
(test '(string=? "abc" "abc"))
(test '(string<=? "abc" "abd"))
(test '(string<? "abc" "abd"))
(test '(string=? "(a b c)" (call-with-output-string (lambda (x) (display '(a b c) x)))))
(test '(string=? "(a b c)" (call-with-truncated-output-string 1000 (lambda (x) (display '(a b c) x)))))
(test '(string<? "a" "b" "c" "d"))
(test '(string=? "(a b c)" (let ((s (open-output-string))) (display '(a b c) s) (get-output-string s))))
(test '(string=? "abc" (list->string (list #\a #\b #\c))))
(test '(string=? "abc" (string #\a #\b #\c)))
(test '(string=? "abc" (string-copy "abc")))
(test '(string=? "aBc" (string-set! "abc" 1 #\B)))
(test '(string=? "abc" (symbol->string 'abc)))
(test '(string=? "(a b c)" (write-to-string '(a b c))))
(test '(string>=? "abd" "abc"))
(test '(string>? "abd" "abc"))
(test '(string-ci<? "a"))
(test '(string-ci=? "a"))
(test '(string-ci=? "a" "a" "a" "a"))
(test '(string-ci=? "a" "a" "A" "a"))
(test '(string-ci>=? "aBc" "ABB"))
(test '(string-ci<=? "ABC" "abc"))
(test '(string-ci=? "ABC" "aBc"))
(test '(string-ci<? "ABC" "abd"))
(test '(string-ci<? "a" "b" "c" "d"))
(test '(string-ci<? "a" "B" "c" "D"))
(test '(string-ci>? "ABd" "abC"))
(test '(string? (string #\a #\b #\c)))
(test '(symbol? 'a))
(test '(symbol=? 'a 'a (string->symbol "a")))
;; (test '(symbol=? '|A| (string->symbol "A")))
(test '(vector? (list->vector (list 1 2 3))))
(test '(vector? (make-vector 3)))

(test '(string=? "a"))
(test '(string=? "a" "a" "a" "a"))
(test '(not (string=? "a" "a" "A" "a")))
(test '(string-ci=? "a"))
(test '(string-ci=? "a" "a" "a" "a"))
(test '(string-ci=? "a" "a" "A" "a"))
(test '(not (string-ci=? "a" "a" "A" "b")))
(test '(string<? "a"))
(test '(string<? "a" "b" "c" "d"))
(test '(not (string<? "a" "B" "c" "D")))
(test '(not (string<? "a" "a" "A" "b")))
(test '(string-ci<? "a"))
(test '(string-ci<? "a" "b" "c" "d"))
(test '(string-ci<? "a" "B" "c" "D"))
(test '(not (string-ci<? "a" "a" "A" "b")))

(test '(equal? '(#\a #\b #\c #\d #\e #\f) (string->list "abcdef")))
(test '(equal? '(#\c #\d #\e #\f) (string->list "abcdef" 2)))
(test '(equal? '(#\c #\d #\e) (string->list "abcdef" 2 5)))

(test '(equal? "abcdef" (string-copy "abcdef")))
(test '(equal? "cdef" (string-copy "abcdef" 2)))
(test '(equal? "cde" (string-copy "abcdef" 2 5)))

(test '(equal? "abc12f" (let ((s (string-copy "abcdef"))) (string-copy! s 3 "12") s)))
(test '(equal? "a23def" (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 1) s)))
(test '(equal? "a23def" (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 1) s)))
(test '(equal? "a3cdef" (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 2) s)))

(test '(equal? "a12def" (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 0 2) s)))
(test '(equal? "a123ef" (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 0 3) s)))
(test '(equal? "ababcfg" (let ((s (string-copy "abcdefg")))   (string-copy! s 2 s 0 3) s)))
(test '(equal? "efcdefg" (let ((s (string-copy "abcdefg")))   (string-copy! s 0 s 4 6) s)))
(test '(equal? "abcde" (let ((x (string-copy "abcde"))) (string-fill! x #\1 2 2) x)))
(test '(equal? "ab11e" (let ((x (string-copy "abcde"))) (string-fill! x #\1 2 4) x)))
(test '(equal? "ab111" (let ((x (string-copy "abcde"))) (string-fill! x #\1 2 5) x)))

(test '(equal? #(a b c 1 2 f) (let ((v (vector-copy #(a b c d e f)))) (vector-copy! v 3 #(1 2)) v)))
(test '(equal? #(a 2 3 d e f) (let ((v (vector-copy #(a b c d e f)))) (vector-copy! v 1 #(1 2 3) 1) v)))
(test '(equal? #(a 3 c d e f) (let ((v (vector-copy #(a b c d e f)))) (vector-copy! v 1 #(1 2 3) 2) v)))
(test '(equal? #(a b c d e f) (let ((v (vector-copy #(a b c d e f)))) (vector-copy! v 1 #(1 2 3) 3) v)))
(test '(equal? #(a 1 2 d e f) (let ((v (vector-copy #(a b c d e f)))) (vector-copy! v 1 #(1 2 3) 0 2) v)))
(test '(equal? #(a 1 2 3 e f) (let ((v (vector-copy #(a b c d e f)))) (vector-copy! v 1 #(1 2 3) 0 3) v)))

;; this next one fails because overlap is not handled correctly
;; (test '(equal? #(a b a b c f g) (let ((v (vector 'a 'b 'c 'd 'e 'f 'g))) (vector-copy! v 2 v 0 3) v)))

(test '(equal? #(e f c d e f g) (let ((v (vector 'a 'b 'c 'd 'e 'f 'g))) (vector-copy! v 0 v 4 6) v)))

(test '(equal? #(1 2 smash smash 5)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'smash 2 4) vec)))
(test '(equal? #(x x x x x)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x) vec)))
(test '(equal? #(1 2 x x x)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x 2) vec)))
(test '(equal? #(1 2 x 4 5)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x 2 3) vec)))
(test '(equal? #(1 2 x x x)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x 2 5) vec)))
(test '(equal? #(1 2 3 4 5)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x 2 2) vec)))

(test '(begin (call-with-output-file "/tmp/fac20.out"
               (lambda (port) (display (fac 20) port)))
              (call-with-input-file "/tmp/fac20.out"
               (lambda (port) (= (fac 20) (read port))))))

(test '(begin (with-output-to-file "/tmp/fac20.out"
               (lambda () (display (fac 20))))
              (with-input-from-file "/tmp/fac20.out"
               (lambda () (= (fac 20) (read))))))

(test '(let ((fib20 (fib 20))
             (output-port (open-output-file "/tmp/fib20.out")))
            (display fib20 output-port)
            (close-output-port output-port)
            (= fib20 (read (open-input-file "/tmp/fib20.out")))))

(test #t)

(display "tests complete.") (newline)
