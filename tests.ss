
(define counter (make-counter))

(define integers
    (letrec ((next
              (lambda (n)
                (delay (cons n (next (+ n 1)))))))
            (next 0)))

(define head
    (lambda (stream) (car (force stream))))

(define tail
    (lambda (stream) (cdr (force stream))))

(define (fibs)
    (let ((f '(1 1)))
         (while (positive? (car f))
                (set! f (cons (+ (car f) (cadr f)) f)))
         (cdr f)))

(define (foo x)
        (define (bar x)
                (define (baz x)
                        (product 3 x))
        (product 5
           (baz x)))
    (product 7
       (bar x)))

(define (epsilon)
    (let ((e 1.0))
        (while (not (= 1.0 (+ 1.0 e)))
               (set! e (/ e 2)))
        (+ e e)))

(define (s n k)
    (cond ((= k 1) 1)
          ((= k n) 1)
          (else (+ (s (- n 1) (- k 1)) (* k (s (- n 1) k))))))

(define bbbbb '(b))
(define aaaaa (list bbbbb bbbbb bbbbb bbbbb bbbbb))
(set-cdr! (cddddr aaaaa) aaaaa)

(define (test s)
        (unless (eq? #t (eval s (environment)))
                (begin (display 'fail) (space) (display s)))
        (gc))

(test '(string=? "#0=(#1=(b) #1# #1# #1# #1# . #0#)" (write-to-string aaaaa)))

(test '(eqv? '(1 2 4 5 7 8) (numeric-sort '(1 4 2 8 5 7))))

(test '(string=?  "aaaaabbcdrr" (list->string (char-sort (string->list "abracadabra")))))

(test '(eqv? (iota 50) (sort < (shuffle (make-random) (iota 50)))))

(test '(= 0 0))
(test '(= (~ 0) -1))
(test '(= 1.0 (cos (acos 1.0))))
(test '(= 1.0 (exp 0.0)))
(test '(= 1.0 (floor 1.5)))
(test '(= 1.0 (sin (asin 1.0))))
(test '(= -1.0 (truncate -1.5)))
(test '(= 1 (* 2/3 3/2)))
(test '(= (- 1 2 3) -4))
(test '(= 128 (expt 2 7)))
(test '(= 1 (% 3 2)))
(test '(= 13 (fib 5)))
(test '(= 1/6 (- 1/2 1/3)))
(test '(= 1 (>> 8 3)))
(test '(= 1 (cos (acos 1))))
(test '(= 1 (counter)))
(test '(= 1 (exp 0)))
(test '(= 1 (floor 1.5)))
(test '(= 1 (sin (asin 1))))
(test '(= -1 (truncate -1.5)))
(test '(= 2.0 (+ 2.0 (epsilon))))
(test '(= 2.0 (exact->inexact 2)))
(test '(< 2 3))
(test '(= 2 (- 5 3)))
(test '(= 29 (ack 3 2)))
(test '(= 2 (counter)))
(test '(= 2 (exact->inexact 2)))
(test '(= 2 (gcd 12 10)))
(test '(= 2 (head (tail (tail integers)))))
(test '(= 3.0 (imag-part 5.0+3.0i)))
(test '(= 30 (lcm 12 10)))
(test '(= 3.0 (round 3.1)))
(test '(= 3.0 (sqrt 9.0)))
(test '(= 3 (/ 12 4)))
(test '(= '3 (+ 2 1)))
(test '(= (% 3 2) 1))
(test '(= 3 (+ 2 1)))
(test '(= 3/2 (/ 3/4 1/2)))
(test '(= 3/2 (rationalize 1.5)))
(test '(<= 3 3))
(test '(= 3 3))
(test '(>= 3 3))
(test '(= (* 3 4) 12))
(test '(= (+ 3 4) 7))
(test '(= 3628800 (let ((p 1) (n 10)) (while (> n 0) (set! p (* n p)) (set! n (- n 1)) p))))
(test '(= 362880 (apply * (cdr (iota 10)))))
(test '(= 3 (begin 1 2 3)))
(test '(= 3 (counter)))
(test '(= 3 (if #t 3 2)))
(test '(= 3 (imag-part 5+3i)))
(test '(= 3 (inexact->exact 3)))
(test '(= 3 (inexact->exact 3.0)))
(test '(= 3 (isqrt 9)))
(test '(= 3 (length '(a b c))))
(test '(= 3 (let ((r 0)) (begin (unless #f 1 2 (set! r 3)) r))))
(test '(= 3 (let ((r 0)) (begin (when   #t 1 2 (set! r 3)) r))))
(test '(= 3 (max 1 3 2)))
(test '(= 3 (min 4 3 6)))
(test '(= 3 (round 3.1)))
(test '(= 3 (sqrt 9)))
(test '(= 3 (string-length "abc")))
(test '(= 3 (string->number "3")))
(test '(= 3 (vector-length (list->vector (list 1 2 3)))))
(test '(= 3 (vector-length (vector 1 2 3))))
(test '(= 4.0 (imag-part 3.0+4.0i)))
(test '(= (/ 4 2) 2))
(test '(= 45.0 (real-part 45.0+18.0i)))
(test '(= 45 (real-part 45+18i)))
(test '(= 45 (string-length (make-string 45))))
(test '(= 4 (cond (#f 1) (#f 2) (#t 3 4) (#f 4) (else 5))))
(test '(= 4 (do ((i 1 (+ 1 i))) ((> i 4)) i)))
(test '(= 4 (imag-part 3+4i)))
(test '(= 5.0 (real-part 5.0+3.0i)))
(test '(= (& 5 2) 0))
(test '(= 525 (foo 5)))
(test '(> 5 3))
(test '(= 5 (| 4 1)))
(test '(= 5/6 (+ 1/2 1/3)))
(test '(= 5 (cond (#f 1) (#f 2) (#f 3) (#f 4) (else 5))))
(test '(= 5 (force (delay 5))))
(test '(= 5 (real-part 5+3i)))
(test '(= 6 (* 2 3)))
(test '(= 65 (char->integer #\A)))
(test '(= 6 (fac 3)))
(test '(= 6 (tak 7 6 5)))
(test '(= (^ 7 2) 5))
(test '(= 7 (eval '(+ 3 4) (environment))))
(test '(= 7 (s 4 2)))
(test '(= 7129/2520 (apply + (map / (cdr (iota 10))))))
(test '(= 8 (<< 1 3)))
(test '(<= (abs (- 1.0 (log (exp 1.0)))) 1e-7))
(test '(<= (abs (- 1.0 (tan (atan 1.0)))) 1e-7))
(test '(<= (abs (- 1 (log (exp 1)))) 1e-07))
(test '(<= (abs (- 1 (tan (atan 1)))) 1e-07))
(test '(= (abs -7) 7))
(test '(<= (abs (- 8.0 (pow 2.0 3.0))) 1e-7))
(test '(<= (abs (- 8 (pow 2 3))) 1e-07))
(test '(<= (abs (- (sqrt 2.0) (magnitude 1.0+1.0i))) 1e-7))
(test '(<= (abs (- (sqrt 2) (magnitude 1+1i))) 1e-07))
(test '(alist? '((a . b) (c . d))))
(test '(and #t #t))
(test '(< (- (angle 1.0+1.0i) 0.785398163397448) 1e-7))
(test '(< (- (angle 1+1i) 0.785398163397448) 1e-07))
(test '(= (ceiling 1.5) 2))
(test '(= (ceiling 1.5) 2.0))
(test '(char? #\a))
(test '(char=? #\a #\a))
(test '(char<=? #\a #\b))
(test '(char<? #\a #\b))
(test '(char=? #\a (char-downcase #\A)))
(test '(char=? #\A (char-upcase #\a)))
(test '(char=? #\A (integer->char 65)))
(test '(char-alphabetic? #\a))
(test '(char=? #\A (string-ref "aAa" 1)))
(test '(char>=? #\b #\a))
(test '(char>? #\b #\a))
(test '(char-ci=? #\A #\a))
(test '(char-ci<=? #\A #\b))
(test '(char-ci>=? #\B #\a))
(test '(char-ci>? #\B #\a))
(test '(char-ci<? #\B #\c))
(test '(char-lower-case? #\a))
(test '(char-numeric? #\0))
(test '(char-upper-case? #\A))
(test '(char-whitespace? #\space))
(test '(complex? 3.0+4.0i))
(test '(complex? 3+4i))
(test '(complex? 4.0+3.0i))
(test '(complex? 4+3i))
(test '(eq? 'a 'a))
(test '(eq? 'a (apply car '((a b)))))
(test '(eq? 'a (car '(a))))
(test '(eq? 'a (vector-ref (list->vector '(b a a)) 1)))
(test '(eq? 'b (cadr '(a b))))
(test '(eqv? '(b) (cdr '(a b))))
(test '(eq? 'c (caddr '(a b c))))
(test '(eqv? '(c) (cddr '(a b c))))
(test '(eq? 'composite (case (* 2 3) ((2 3 5 7) 'prime) ((4 6 8 9) 'composite))))
(test '(eq? 'd (assv 'c '((a . b) (c . d)))))
(test '(eq? 'd (cadddr '(a b c d))))
(test '(eqv? '(d) (cdddr '(a b c d))))
(test '(eqv? '(e) (cddddr '(a b c d e))))
(test '(eqv? '(0 1 2) (let ((a 0) (b 1) (c 2)) (list a b c))))
(test '(eqv? '(0 1 2) (let* ((a 0) (b (+ a 1)) (c (+ b 1))) (list a b c))))
(test '(eqv? '(1 1/2 1/3 1/4 1/5 1/6 1/7 1/8 1/9) (map / (cdr (iota 10)))))
(test '(eqv? '(1 1/2 1/6 1/24 1/120 1/720 1/5040 1/40320 1/362880) (map (lambda (x) (/ (fac x))) (cdr (iota 10)))))
(test '(eqv? '(1 2 3) '(1 2 3)))
(test '(eqv? '(1 2 3) (list 1 2 3)))
(test '(eqv? 1/6 (- 1/2 1/3)))
(test '(eqv? 3.0 (imag-part 5.0+3.0i)))
(test '(eqv? '(3 2 1) (reverse '(1 2 3))))
(test '(eqv? '(3 2 1) (reverse! '(1 2 3))))
(test '(eqv? 3/2 (/ 3/4 1/2)))
(test '(eqv? 5/6 (+ 1/2 1/3)))
(test '(eqv? `(a ,(+ 3 4) b) '(a 7 b)))
(test '(eqv? '(a b 1 2 3 c d) `(a b ,@(list 1 2 3) c d)))
(test '(eqv? '(a b) (begin (let ((s '(a a))) (set-cdr! s '(b)) s))))
(test '(eqv? '(a b) (begin (let ((s '(b b))) (set-car! s 'a) s))))
(test '(eqv? '(a b c) (cons 'a '(b c))))
(test '(eqv? '(a b c d e) (append '(a b c) '(d e))))
(test '(eqv? '(a b c) (read (open-input-string "(a b c)" 0 7))))
(test '(eqv? `(a ,@(list 1 2 3) b c) '(a 1 2 3 b c)))
(test '(eqv? `(a (unquote-splicing (list 1 2 3)) b c) '(a 1 2 3 b c)))
(test '(eqv? '(b) (cdr '(a b))))
(test '(eqv? '(c) (cddr '(a b c))))
(test '(eqv? '(c . d) (assoc 'c '((a . b) (c . d)))))
(test '(eqv? '(c . d) (assq 'c '((a . b) (c . d)))))
(test '(eqv? '(c d e) (list-tail '(a b c d e) 2)))
(test '(eqv? 'c (list-ref '(a b c d e) 2)))
(test '(eqv? '(d) (cdddr '(a b c d))))
(test '(eqv? '(e) (cddddr '(a b c d e))))
(test '(eqv? (list 1 2 3) (vector->list (list->vector (list 1 2 3)))))
(test '(eqv? (list->vector (list 1 2 3)) (list->vector (list 1 2 3))))
(test '(eqv? 3/2 (rationalize 1.5)))
(test '(exact? 2))
(test '(= (imag-part 3.0+4.0i) 4.0))
(test '(not (inexact? 3)))
(test '(inexact? 3.0))
(test '(inexact? 3.1))
(test '(integer? 3))
(test '(let ((b 'b)) (let ((a (list b b b b b))) (set-cdr! (cddddr a) a) (cyclic? a))))
;; (test '(let ((f (fibs))) (= (+ 0.0 (/ (car f) (cadr f))) (/ (+ 1 (sqrt 5)) 2))))
(test '(list? '(1 2 3)))
(test '(negative? -3))
(test '(not (boolean? 5)))
(test '(not #f))
(test '(not (null? #f)))
(test '(not (string? 'abc)))
(test '(null? '()))
(test '(not (null? #f)))
(test '(number? 3))
(test '(or #f #f #t #f))
(test '(pair? '(a . b)))
(test '(positive? 3))
(test '(procedure? fib))
(test '(procedure? procedure?))
(test '(rational? 5/6))
(test '(real? 45))
(test '(real? 45.0))
(test '(real? 45.1))
(test '(= (sin (asin 1.0)) 1.0))
(test '(= (sin (asin 1)) 1))
(test '(string=? "(0 1 2 3 4 5 6 7 8 " (call-with-truncated-output-string 20 (lambda (port) (write (iota 50) port)))))
(test '(string=? "3" (number->string 3)))
(test '(string=? "AAA" (string-fill! (make-string 3) #\A)))
(test '(string=? "aA" (substring "baA" 1 3)))
(test '(string? (string #\a #\b #\c)))
(test '(string? "abc"))
(test '(string=? "abc" "abc"))
(test '(string<=? "abc" "abd"))
(test '(string<? "abc" "abd"))
(test '(string=? "(a b c)" (call-with-output-string (lambda (x) (display '(a b c) x)))))
(test '(string=? "(a b c)" (call-with-truncated-output-string 1000 (lambda (x) (display '(a b c) x)))))
(test '(string=? "(a b c)" (let ((s (open-output-string))) (display '(a b c) s) (get-output-string s))))
(test '(string=? "abc" (list->string (list #\a #\b #\c))))
(test '(string=? "abc" (string #\a #\b #\c)))
(test '(string=? "abc" (string-copy "abc")))
(test '(string=? "aBc" (string-set! "abc" 1 #\B)))
(test '(string=? "abc" (symbol->string 'abc)))
(test '(string=? "(a b c)" (write-to-string '(a b c))))
(test '(string>=? "abd" "abc"))
(test '(string>? "abd" "abc"))
(test '(string-ci>=? "aBc" "ABB"))
(test '(string-ci<=? "ABC" "abc"))
(test '(string-ci=? "ABC" "aBc"))
(test '(string-ci<? "ABC" "abd"))
(test '(string-ci>? "ABd" "abC"))
(test '(string? (string #\a #\b #\c)))
(test '(symbol? 'a))
(test '(= 3 (vector-length (list->vector (list 1 2 3)))))
(test '(vector? (list->vector (list 1 2 3))))
(test '(vector? (make-vector 3)))

(test '(begin (call-with-output-file "/tmp/fac20.out"
               (lambda (port) (display (fac 20) port)))
              (call-with-input-file "/tmp/fac20.out"
               (lambda (port) (= (fac 20) (read port))))))

(test '(begin (with-output-to-file "/tmp/fac20.out"
               (lambda () (display (fac 20))))
              (with-input-from-file "/tmp/fac20.out"
               (lambda () (= (fac 20) (read))))))

(test '(let ((fib20 (fib 20))
             (output-port (open-output-file "/tmp/fib20.out")))
            (display fib20 output-port)
            (close-output-port output-port)
            (eqv? fib20 (read (open-input-file "/tmp/fib20.out")))))

(test #t)

(display "tests complete.") (newline)

