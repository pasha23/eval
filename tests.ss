(define counter (make-counter))

(define integers
    (letrec ((next
              (lambda (n)
                (delay (cons n (next (+ n 1)))))))
            (next 0)))

(define head
    (lambda (stream) (car (force stream))))

(define tail
    (lambda (stream) (cdr (force stream))))

(define (fibs)
    (let ((f '(1 1)))
         (while (> (car f) 0)
                (set! f (cons (+ (car f) (cadr f)) f)))
         (cdr f)))

(define (foo x)
        (define (bar x)
                (define (baz x)
                        (product 3 x))
        (product 5
           (baz x)))
    (product 7
       (bar x)))

(define tests '(
    (= 0 0)
    (= (~ 0) -1)
    (= 5 (cond (#f 1) (#f 2) (#f 3) (#f 4) (else 5)))
    (= 4 (cond (#f 1) (#f 2) (#t 3 4) (#f 4) (else 5)))
    (= 27676265/7527762 (apply + (map (lambda (x) (/ x)) (cdr (iota 30)))))
    (string=? "(0 1 2 3 4 5 6 7 8 " (call-with-truncated-output-string 20 (lambda (port) (write (iota 50) port))))

    (= 525 (foo 5))
    (= 1.0 (cos (acos 1.0)))
    (= 1.0 (exp 0.0))
    (= 1.0 (floor 1.5))
    (= 1.0 (sin (asin 1.0)))
    (= -1.0 (truncate -1.5))
    (= 1 (* 2/3 3/2))
    (= (- 1 2 3) -4)
    (= 128 (expt 2 7))
    (= 1 (% 3 2))
    (= 13 (fib 5))
    (= 157 (numerator (rationalize 3.14)))
    (= 1/6 (- 1/2 1/3))
    (= 1 (>> 8 3))
    (= 1 (counter))
    (= 2.0 (exact->inexact 2))
    (< 2 3)
    (= 2 (- 5 3))
    (= 29 (ack 3 2))
    (= 2 (counter))
    (= 2 (gcd 12 10))
    (= 3.0 (imag-part 5.0+3.0i))
    (= 30 (lcm 12 10))
    (= 3.0 (round 3.1))
    (= 3.0 (sqrt 9.0))
    (= 3 (isqrt 9))
    (= 3 (/ 12 4))
    (= 3 (+ 2 1))
    (= (% 3 2) 1)
    (= 3/2 (/ 3/4 1/2))
    (= 3/2 (rationalize 1.5))
    (<= 3 3)
    (= 3 3)
    (>= 3 3)
    (= (* 3 4) 12)
    (= (+ 3 4) 7)
    (= 3628800 (let ((p 1) (n 10)) (while (> n 0) (set! p (* n p)) (set! n (- n 1)) p)))
    (= 362880 (apply * (cdr (iota 10))))
    (= 3 (begin 1 2 3))
    (= 3 (counter))
    (= 3 (if #t 3 2))
    (= 3 (inexact->exact 3.0))
    (= 3 (length '(a b c)))
    (= 3 (max 1 3 2))
    (= 3 (min 4 3 6))
    (= 3 (string-length "abc"))
    (= 3 (string->number "3"))
    (= 3 (vector-length (list->vector (list 1 2 3))))
    (= 3 (vector-length (vector 1 2 3)))
    (= 41/15 (apply + (map / (cdr (iota 10)))))
    (= (/ 4 2) 2)
    (= 45.0 (real-part 45.0+18.0i))
    (= 45 (string-length (make-string 45)))
    (= 4 (do ((i 1 (+ 1 i))) ((> i 4)) i))
    (= 50 (denominator (rationalize 3.14)))
    (= 5.0 (real-part 5.0+3.0i))
    (= (& 5 2) 0)
    (> 5 3)
    (= 5 (| 4 1))
    (= 5/6 (+ 1/2 1/3))
    (= 5 (force (delay 5)))
    (= 6 (* 2 3))
    (= 65 (char->integer #\A))
    (= 6 (fac 3))
    (= 6 (tak 7 6 5))
    (= (^ 7 2) 5)
    (= 7 (eval '(+ 3 4) (environment)))
    (= 8 (<< 1 3))
    (<= (abs (- 1.0 (log (exp 1.0)))) 1e-15)
    (<= (abs (- 1.0 (tan (atan 1.0)))) 1e-15)
    (= (abs -7) 7)
    (<= (abs (- 8.0 (pow 2.0 3.0))) 1e-15)
    (<= (abs (- (sqrt 2.0) (magnitude 1.0+1.0i))) 1e-15)
    (alist? '((a . b) (c . d)))
    (and #t #t)
    (< (- (angle 1.0+1.0i) 0.785398163397448) 1e-15)
    (= (ceiling 1.5) 2.0)
    (char? #\a)
    (char=? #\a #\a)
    (char<=? #\a #\b)
    (char<? #\a #\b)
    (char=? #\a (char-downcase #\A))
    (char=? #\A (char-upcase #\a))
    (char=? #\A (integer->char 65))
    (char-alphabetic? #\a)
    (char=? #\A (string-ref "aAa" 1))
    (char>=? #\b #\a)
    (char>? #\b #\a)
    (char-ci=? #\A #\a)
    (char-ci<=? #\A #\b)
    (char-ci>=? #\B #\a)
    (char-ci>? #\B #\a)
    (char-ci<? #\B #\c)
    (char-lower-case? #\a)
    (char-numeric? #\0)
    (char-upper-case? #\A)
    (char-whitespace? #\space)
    (complex? 3.0+4.0i)
    (complex? 4.0+3.0i)
    (eq? 'a 'a)
    (eq? 'a (apply car '((a b))))
    (eq? 'a (car '(a)))
    (eq? 'a (vector-ref (list->vector '(b a a)) 1))
    (eq? 'b (cadr '(a b)))
    (eq? 'c (caddr '(a b c)))
    (eq? 'd (assv 'c '((a . b) (c . d))))
    (eq? 'd (cadddr '(a b c d)))
    (eqv? '(0 1 2) (let ((a 0) (b 1) (c 2)) (list a b c)))
    (eqv? '(0 1 2) (let* ((a 0) (b (+ a 1)) (c (+ b 1))) (list a b c)))
    (eqv? '(1 1/2 1/3 1/4 1/5 1/6 1/7 1/8 1/9) (map / (cdr (iota 10))))
    (eqv? '(1 2 3) '(1 2 3))
    (eqv? '(1 2 3) (list 1 2 3))
    (eqv? '(3 2 1) (reverse '(1 2 3)))
    (eqv? '(3 2 1) (reverse! '(1 2 3)))
    (eqv? `(a ,(+ 3 4) b) '(a 7 b))
    (eqv? '(a b 1 2 3 c d) `(a b ,@(list 1 2 3) c d))
    (eqv? '(a b) (begin (let ((s '(a a))) (set-cdr! s '(b)) s)))
    (eqv? '(a b) (begin (let ((s '(b b))) (set-car! s 'a) s)))
    (eqv? '(a b c) (cons 'a '(b c)))
    (eqv? '(a b c d e) (append '(a b c) '(d e)))
    (eqv? `(a (unquote-splicing (list 1 2 3)) b c) '(a 1 2 3 b c))
    (eqv? '(b) (cdr '(a b)))
    (eqv? '(c) (cddr '(a b c)))
    (eqv? '(c . d) (assoc 'c '((a . b) (c . d))))
    (eqv? '(c . d) (assq 'c '((a . b) (c . d))))
    (eqv? '(c d e) (list-tail '(a b c d e) 2))
    (eqv? 'c (list-ref '(a b c d e) 2))
    (eqv? '(d) (cdddr '(a b c d)))
    (eqv? '(e) (cddddr '(a b c d e)))
    (eqv? (list 1 2 3) (vector->list (list->vector (list 1 2 3))))
    (eqv? (list->vector (list 1 2 3)) (list->vector (list 1 2 3)))
    (exact? 2)
    (= (imag-part 3.0+4.0i) 4.0)
    (inexact? 3.1)
    (integer? 3)
    (let ((b 'b)) (let ((a (list b b b b b))) (set-cdr! (cddddr a) a) (cyclic? a)))
    (list? '(1 2 3))
    (negative? -3)
    (not (boolean? 5))
    (not #f)
    (null? '())
    (number? 3)
    (or #f #f #t #f)
    (pair? '(a . b))
    (positive? 3)
    (procedure? fib)
    (procedure? procedure?)
    (rational? 5/6)
    (= (rationalize 3.14159265358979) 144029661/45846065)
    (real? 45)
    (real? 45.1)
    (= (sin (asin 1.0)) 1.0)
    (string=? "3" (number->string 3))
    (string=? "AAA" (string-fill! (make-string 3) #\A))
    (string=? "aA" (substring "baA" 1 3))
    (string? "abc")
    (string=? "abc" "abc")
    (string<=? "abc" "abd")
    (string<? "abc" "abd")
    (string=? "abc" (list->string (list #\a #\b #\c)))
    (string=? "abc" (string #\a #\b #\c))
    (string=? "abc" (string-copy "abc"))
    (string=? "aBc" (string-set! "abc" 1 #\B))
    (string=? "abc" (symbol->string 'abc))
    (string>=? "abd" "abc")
    (string>? "abd" "abc")
    (string-ci>=? "aBc" "ABB")
    (string-ci<=? "ABC" "abc")
    (string-ci=? "ABC" "aBc")
    (string-ci<? "ABC" "abd")
    (string-ci>? "ABd" "abC")
    (string? (string #\a #\b #\c))
    (symbol? 'a)
    (vector? (list->vector (list 1 2 3)))
    (vector? (make-vector 3))

    (= 3 (let ((r 0)) (begin (unless #f 1 2 (set! r 3)) r)))
    (= 3 (let ((r 0)) (begin (when   #t 1 2 (set! r 3)) r)))
    (eq? 'composite (case (* 2 3) ((2 3 5 7) 'prime) ((4 6 8 9) 'composite)))
    (let ((f (fibs))) (= (+ 0.0 (/ (car f) (cadr f))) (/ (+ 1 (sqrt 5)) 2)))
    (= 2 (head (tail (tail integers))))

    (begin (call-with-output-file "/tmp/fac20.out" (lambda (port) (display (fac 20) port)))
           (call-with-input-file "/tmp/fac20.out" (lambda (port) (= (fac 20) (read port)))))

    (begin (with-output-to-file "/tmp/fac20.out"   (lambda () (display (fac 20))))
           (with-input-from-file "/tmp/fac20.out"  (lambda () (= (fac 20) (read)))))

    (let ((fib20 (fib 20))
          (output-port (open-output-file "/tmp/fib20.out")))
         (display fib20 output-port)
         (close-output-port output-port)
         (eqv? fib20 (read (open-input-file "/tmp/fib20.out"))))

    (string=? "(a b c)" (write-to-string '(a b c)))
    (string=? "(a b c)" (let ((s (open-output-string))) (display '(a b c) s) (get-output-string s)))
    (eqv? '(a b c) (read (open-input-string "(a b c)" 0 7)))
    (string=? "(a b c)" (call-with-output-string (lambda (x) (display '(a b c) x))))
    (string=? "(a b c)" (call-with-truncated-output-string 1000 (lambda (x) (display '(a b c) x))))
    #t
))

(let ((t tests))
     (while (pair? t)
            (if (eqv? #t (eval (car t) (environment)))
                (begin (display (car t)) (space) (display 'pass) (newline))
                (begin (display (car t)) (space) (display 'fail) (newline)))
            (set! t (cdr t))))

